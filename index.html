<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ruleta de la Muerte ðŸ’€</title>
    <!-- Carga de Tailwind CSS para un diseÃ±o moderno y responsivo -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Carga de Tone.js para generar sonido -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
      /* Fuentes temÃ¡ticas de Halloween */
      @import url("https://fonts.googleapis.com/css2?family=Creepster&family=Nosifier&display=swap");

      body {
        font-family: "Nosifier", sans-serif;
        background-color: #1a1a1a; /* Fondo oscuro de Halloween */
        color: #f0f0f0; /* Texto claro */
      }
      h1,
      h2,
      h3 {
        font-family: "Creepster", cursive; /* Fuente escalofriante para tÃ­tulos */
        color: #ff6600; /* Naranja calabaza */
      }
      .roulette-wheel {
        width: 500px;
        height: 500px;
        border-radius: 50%;
        border: 10px solid #5a0000; /* Borde interior de metal oxidado */
        box-shadow: 0 0 40px rgba(255, 0, 0, 0.5),
          /* Resplandor rojo oscuro */ 0 0 0 15px #000000,
          /* Anillo exterior negro */ 0 0 0 25px #300000; /* Anillo de sangre seca */
        transition: transform 6s cubic-bezier(0.25, 0.1, 0.25, 1);
        position: relative;
        background-color: #2a2a2a; /* Fondo oscuro para la ruleta */
      }

      /* 1. Marcador tÃ©trico (Estaca de Hueso/Metal) */
      .marker {
        width: 0;
        height: 0;
        border-left: 18px solid transparent;
        border-right: 18px solid transparent;
        border-top: 50px solid #cc0000; /* Rojo sangre para la flecha */
        position: absolute;
        top: -50px; /* Ajustado por el nuevo tamaÃ±o */
        left: 50%;
        transform: translateX(-50%);
        z-index: 100;
        /* Sombra para darle profundidad */
        filter: drop-shadow(0 0 5px #ff6600);
      }

      /* 2. AnimaciÃ³n de Salpicaduras de Sangre/Chispas del puntero */
      @keyframes blood-splatter {
        0% {
          transform: translate(0, 0) scale(0.5);
          opacity: 0;
        }
        5% {
          transform: translate(5px, -15px) scale(1);
          opacity: 1;
        }
        100% {
          transform: translate(20px, 40px) scale(0);
          opacity: 0;
        }
      }

      .splatter {
        position: absolute;
        width: 8px;
        height: 8px;
        background-color: #ff0000; /* Rojo Sangre */
        border-radius: 50%;
        opacity: 0;
        pointer-events: none;
        z-index: 101;
        box-shadow: 0 0 4px #ff6600;
      }

      /* Posiciones aleatorias para las "salpicaduras" cerca del marcador */
      .splatter:nth-child(5) {
        top: -20px;
        left: calc(50% + 5px);
        animation: blood-splatter 0.5s linear infinite;
        animation-delay: 0s;
      }
      .splatter:nth-child(6) {
        top: -10px;
        left: calc(50% - 15px);
        animation: blood-splatter 0.5s linear infinite;
        animation-delay: 0.15s;
      }
      .splatter:nth-child(7) {
        top: -30px;
        left: calc(50% - 25px);
        animation: blood-splatter 0.5s linear infinite;
        animation-delay: 0.3s;
      }
      .splatter:nth-child(8) {
        top: -5px;
        left: calc(50% + 10px);
        animation: blood-splatter 0.5s linear infinite;
        animation-delay: 0.45s;
      }

      /* 3. Estilo de los Eslabones de Cadena */
      .chain-link {
        position: absolute;
        width: 30px;
        height: 30px;
        background: #444; /* Metal base */
        border: 3px solid #666; /* Detalle de metal */
        border-radius: 50%;
        transform: rotate(45deg); /* Para parecer un eslabÃ³n o ancla */
        box-shadow: 0 0 8px rgba(0, 0, 0, 0.8), inset 0 0 5px #111;
        z-index: 50;
        margin: 10px; /* Separa de la esquina */
      }

      /* Posicionamiento de los eslabones */
      .chain-link:nth-child(1) {
        top: 0;
        left: 0;
      }
      .chain-link:nth-child(2) {
        top: 0;
        right: 0;
      }
      .chain-link:nth-child(3) {
        bottom: 0;
        left: 0;
      }
      .chain-link:nth-child(4) {
        bottom: 0;
        right: 0;
      }

      /* Contenedor de la Ruleta */
      #rouletteContainer {
        border: none;
        box-shadow: none;
        border-radius: 0;
        overflow: visible; /* Asegura que el marcador y las salpicaduras no se recorten */
      }

      /* Estilos de los nombres dentro de la ruleta */
      .roulette-wheel .name-text {
        color: #ffffff;
        text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000,
          1px 1px 0 #000, 0 0 10px #ff6600; /* Resplandor intenso */
        background-color: rgba(0, 0, 0, 0.7);
        border: 2px solid #5a0000; /* Borde mÃ¡s oscuro */
      }

      /* Clase para ocultar las salpicaduras cuando la ruleta se detiene */
      .hidden-splatter .splatter {
        display: none !important;
      }

      /* 4. EFECTO DE APARICIÃ“N: SURGIMIENTO FANTASMAL */
      .sealed-destiny-enter {
        /* Estado inicial - fuera de vista, desenfocado, transparente */
        opacity: 0;
        transform: translateY(20px);
        filter: blur(5px);
        transition: all 0.6s ease-out; /* TransiciÃ³n suave de 0.6s */
      }

      .sealed-destiny-enter.active {
        /* Estado final - visible, nÃ­tido, en posiciÃ³n */
        opacity: 1;
        transform: translateY(0);
        filter: blur(0);
      }

      /* Estilo para el texto del ganador para hacerlo mÃ¡s intenso */
      #winnerDisplay {
        color: #ff3333; /* Rojo mÃ¡s brillante */
        text-shadow: 0 0 10px #800000, 0 0 20px #ff0000; /* Doble resplandor de sangre */
      }

      /* Responsive adjustments */
      @media (max-width: 640px) {
        .roulette-container {
          transform: scale(0.65);
          margin: 0 auto;
          height: 350px;
          width: 100%;
          display: flex;
          justify-content: center;
          align-items: center;
        }
        .roulette-wheel {
          width: 300px;
          height: 300px;
        }
      }
    </style>
  </head>
  <body class="p-4 md:p-8 min-h-screen">
    <div id="app" class="max-w-7xl mx-auto">
      <header class="text-center mb-10">
        <h1 class="text-6xl font-extrabold text-orange-600 mb-2 drop-shadow-lg">
          ðŸ’€ Ruleta de la Muerte ðŸ’€
        </h1>
        <p class="text-gray-300 text-lg">
          Â¡Gira la ruleta y descubre quiÃ©n serÃ¡ el prÃ³ximo sacrificio... o el
          afortunado!
        </p>
      </header>

      <main class="flex flex-col lg:flex-row gap-8">
        <!-- Columna de Controles e Historial -->
        <div
          class="lg:w-1/3 p-6 bg-gray-800 rounded-xl shadow-xl h-fit border border-orange-500"
        >
          <h2 class="text-3xl font-semibold mb-4 text-orange-400">
            Administrar Almas
          </h2>

          <!-- Carga de CSV -->
          <div class="mb-6">
            <label
              for="csvFile"
              class="block text-gray-300 text-sm font-bold mb-2"
              >Cargar Nombres desde CSV:</label
            >
            <input
              type="file"
              id="csvFile"
              accept=".csv"
              class="w-full p-3 border border-gray-600 rounded-lg bg-gray-700 text-white focus:ring-orange-500 focus:border-orange-500 transition duration-150"
            />
            <p class="text-gray-400 text-xs mt-1">
              El CSV debe tener los nombres en la primera columna.
            </p>
          </div>

          <!-- Entrada de Nombre Individual -->
          <div class="mb-6">
            <input
              type="text"
              id="nameInput"
              placeholder="AÃ±adir un alma individual (Enter)"
              class="w-full p-3 border border-gray-600 rounded-lg bg-gray-700 text-white focus:ring-orange-500 focus:border-orange-500 transition duration-150"
            />
          </div>

          <!-- Botones de AcciÃ³n -->
          <div class="flex flex-col space-y-3 mb-6">
            <button
              id="spinButton"
              class="w-full bg-red-700 hover:bg-red-800 text-white font-bold py-3 px-6 rounded-lg transition duration-200 shadow-md disabled:bg-gray-600 disabled:cursor-not-allowed border-b-4 border-red-900 active:border-b-0"
            >
              Â¡Girar la Rueda del Destino!
            </button>
            <button
              id="resetButton"
              class="w-full bg-gray-700 hover:bg-gray-900 text-orange-400 font-bold py-3 px-6 rounded-lg transition duration-200 shadow-md border-b-4 border-gray-900 active:border-b-0"
            >
              Reiniciar Almas
            </button>
          </div>

          <!-- Lista de Nombres Restantes -->
          <div class="mt-8">
            <h3 class="text-2xl font-medium mb-3 text-orange-400">
              Almas Restantes (<span id="nameCount">0</span>)
            </h3>
            <ul
              id="nameList"
              class="space-y-2 max-h-60 overflow-y-auto pr-2 custom-scrollbar"
            >
              <!-- Nombres se insertarÃ¡n aquÃ­ -->
            </ul>
            <p id="emptyMessage" class="text-gray-500 italic mt-4 hidden">
              NingÃºn alma a la vista... Â¡AÃ±ade algunas!
            </p>
          </div>
        </div>

        <!-- Columna de la Ruleta y Resultado -->
        <div class="lg:w-2/3 flex flex-col items-center justify-center">
          <!-- Contenedor de la Ruleta -->
          <div
            id="rouletteContainer"
            class="roulette-container relative flex justify-center items-center hidden-splatter"
          >
            <!-- Eslabones de Cadena en las esquinas -->
            <div class="chain-link top-0 left-0"></div>
            <div class="chain-link top-0 right-0"></div>
            <div class="chain-link bottom-0 left-0"></div>
            <div class="chain-link bottom-0 right-0"></div>

            <!-- Elementos de Salpicadura que se activan al girar -->
            <div class="splatter"></div>
            <div class="splatter"></div>
            <div class="splatter"></div>
            <div class="splatter"></div>

            <div class="marker"></div>
            <div id="rouletteWheel" class="roulette-wheel">
              <!-- Segmentos y nombres se generan aquÃ­ por JS -->
            </div>
          </div>

          <!-- Resultado del Giro --><!-- Se aÃ±ade la clase de inicio de animaciÃ³n 'sealed-destiny-enter' -->
          <div
            id="resultBox"
            class="mt-10 p-5 bg-gray-800 rounded-xl shadow-xl w-full max-w-lg text-center sealed-destiny-enter transition duration-500 border border-orange-600"
          >
            <p class="text-3xl font-bold text-gray-200">Â¡Destino Sellado!</p>
            <p
              id="winnerDisplay"
              class="text-5xl font-extrabold mt-2 truncate"
            ></p>
          </div>

          <!-- Modal para cuando se terminan los nombres -->
          <div
            id="finishedModal"
            class="fixed inset-0 bg-black bg-opacity-70 hidden items-center justify-center z-50 p-4"
          >
            <div
              class="bg-gray-900 p-8 rounded-xl shadow-2xl text-center max-w-sm border border-red-700"
            >
              <h3 class="text-4xl font-bold text-red-600 mb-4 font-creepster">
                Â¡Todas las Almas Han Sido Reclamadas!
              </h3>
              <p class="text-lg text-gray-300 mb-6">
                No quedan mÃ¡s nombres en la ruleta de la muerte.
              </p>
              <button
                onclick="document.getElementById('finishedModal').classList.add('hidden');"
                class="bg-red-700 hover:bg-red-800 text-white font-bold py-2 px-4 rounded-lg"
              >
                Cerrar
              </button>
            </div>
          </div>
        </div>
      </main>
    </div>

    <script>
      // =================================================================
      // SOLID IMPLEMENTATION: MODULAR JAVASCRIPT
      // =================================================================

      /**
       * 1. CONFIG (SRP: Single Responsibility Principle)
       * Maneja todas las constantes y valores de configuraciÃ³n.
       */
      const Config = {
        // Colores temÃ¡ticos GÃ“TICOS/SOBRIOS para los segmentos:
        COLORS: [
          "#5A0000",
          "#320032",
          "#004D00",
          "#800000",
          "#4B0082",
          "#220000",
          "#003300",
          "#6A006A",
          "#200020",
        ],
        WHEEL_DURATION: 6000, // 6 segundos
      };

      /**
       * 2. STATE MANAGER (SRP: Single Responsibility Principle)
       * Controla y encapsula el estado mutable de la aplicaciÃ³n (nombres y estado de giro).
       */
      const StateManager = (() => {
        let names = [];
        let isSpinning = false;

        return {
          getNames: () => [...names],
          setNames: (newNames) => {
            names = newNames;
          },
          getIsSpinning: () => isSpinning,
          setIsSpinning: (state) => {
            isSpinning = state;
          },
          addName: (name) => {
            if (name && !names.includes(name)) {
              names.push(name);
              return true;
            }
            return false;
          },
          removeNameByIndex: (index) => {
            if (index >= 0 && index < names.length) {
              const newNames = names.filter((_, i) => i !== index);
              names = newNames;
            }
          },
          resetNames: () => {
            names = [];
          },
        };
      })();

      /**
       * 3. AUDIO CONTROLLER (SRP: Single Responsibility Principle)
       * Maneja toda la lÃ³gica de Tone.js para el sonido de risa malvada.
       */
      const AudioController = (() => {
        // ConfiguraciÃ³n de efectos (Reverb y Distortion)
        const reverb = new Tone.Reverb({
          decay: 4,
          preDelay: 0.1,
          wet: 0.7,
        });
        const distortion = new Tone.Distortion(0.9).connect(reverb);
        reverb.toDestination(); // Conectar la reverb a la salida principal

        const _playLaughSound = () => {
          // Sintetizador FM para un sonido gutural
          const synth = new Tone.FMSynth({
            harmonicity: 0.2,
            modulationIndex: 12,
            oscillator: { type: "sine" },
            modulation: { type: "square" },
            envelope: { attack: 0.1, decay: 0.5, sustain: 0.1, release: 2 },
          }).connect(distortion);

          // Secuencia de notas muy bajas y lentas para simular el "Muajajaja"
          const sequence = ["C1", "G0", "F0", "C1"];
          const durations = ["1n", "1n", "1n", "2n"];

          let time = Tone.now();
          let totalDuration = 0;

          sequence.forEach((note, index) => {
            synth.triggerAttackRelease(
              note,
              durations[index],
              time + totalDuration,
              0.5
            );
            totalDuration += Tone.Time(durations[index]).toSeconds() * 0.8;
          });
        };

        return {
          playEvilLaugh: () => {
            if (Tone.context.state !== "running") {
              // Iniciar AudioContext si es necesario (requiere clic de usuario)
              Tone.start().then(() => _playLaughSound());
            } else {
              _playLaughSound();
            }
          },
        };
      })();

      /**
       * 4. WHEEL RENDERER (SRP: Single Responsibility Principle)
       * Maneja exclusivamente la representaciÃ³n visual de la ruleta (segmentos y textos).
       */
      const WheelRenderer = ((stateManager, config) => {
        const rouletteWheel = document.getElementById("rouletteWheel");

        const getColor = (index) => config.COLORS[index % config.COLORS.length];

        const _renderSegments = (names) => {
          if (names.length === 0) {
            rouletteWheel.style.background = "#333333";
            rouletteWheel.innerHTML = `<div class="absolute inset-0 flex items-center justify-center text-xl md:text-2xl font-creepster text-orange-400 text-center p-10 drop-shadow-lg">
                        Â¡La Ruleta EstÃ¡ VacÃ­a!<br>AÃ±ade Almas o Carga un CSV
                    </div>`;
            return;
          }

          const segmentAngle = 360 / names.length;
          let gradient = "conic-gradient(";
          let currentAngle = 0;

          // 1. Crear el conic-gradient para los segmentos
          names.forEach((name, index) => {
            const color = getColor(index);
            const nextAngle = currentAngle + segmentAngle;
            gradient += `${color} ${currentAngle}deg ${nextAngle}deg`;
            if (index < names.length - 1) {
              gradient += ", ";
            }
            currentAngle = nextAngle;
          });
          gradient += ")";
          rouletteWheel.style.background = gradient;
          rouletteWheel.innerHTML = "";

          // 2. Posicionar y rotar los textos
          names.forEach((name, index) => {
            const textContainer = document.createElement("div");
            const rotation = index * segmentAngle + segmentAngle / 2;

            textContainer.className =
              "absolute top-0 left-0 w-full h-full text-center pointer-events-none";
            textContainer.style.transform = `rotate(${rotation}deg)`;

            const nameText = document.createElement("span");
            nameText.textContent = name;
            nameText.className =
              "name-text absolute top-1/4 left-1/2 -translate-x-1/2 py-1 px-2 text-sm md:text-base font-bold rounded-lg max-w-[80px] truncate";
            nameText.style.transform = `translate(-50%, -50%) rotate(-${rotation}deg)`;

            textContainer.appendChild(nameText);
            rouletteWheel.appendChild(textContainer);
          });
        };

        return {
          render: () => {
            const names = stateManager.getNames();
            _renderSegments(names);
          },
          spin: (totalRotation) => {
            rouletteWheel.style.transition = `transform ${
              config.WHEEL_DURATION / 1000
            }s cubic-bezier(0.25, 0.1, 0.25, 1)`;
            rouletteWheel.style.transform = `rotate(${totalRotation}deg)`;
          },
          stopSpin: (normalizedRotation) => {
            rouletteWheel.style.transition = "none";
            rouletteWheel.style.transform = `rotate(${normalizedRotation}deg)`;
          },
        };
      })(StateManager, Config);

      /**
       * 5. UI CONTROLLER (SRP: Single Responsibility Principle)
       * Maneja todos los elementos de la interfaz de usuario no relacionados con la ruleta en sÃ­.
       */
      const UIController = ((stateManager, audioController) => {
        const spinButton = document.getElementById("spinButton");
        const winnerDisplay = document.getElementById("winnerDisplay");
        const resultBox = document.getElementById("resultBox");
        const nameCountDisplay = document.getElementById("nameCount");
        const emptyMessage = document.getElementById("emptyMessage");
        const nameListElement = document.getElementById("nameList");
        const finishedModal = document.getElementById("finishedModal");
        const rouletteContainer = document.getElementById("rouletteContainer");

        const toggleSpinButton = (isSpinning) => {
          spinButton.disabled =
            isSpinning || stateManager.getNames().length === 0;
        };

        const _updateNameList = (names) => {
          nameListElement.innerHTML = "";
          if (names.length === 0) {
            emptyMessage.classList.remove("hidden");
          } else {
            emptyMessage.classList.add("hidden");
            names.forEach((name) => {
              const li = document.createElement("li");
              li.className =
                "flex justify-between items-center p-2 bg-gray-700 rounded-md text-gray-200 hover:bg-gray-600 transition duration-100 border border-gray-600";
              li.innerHTML = `<span>${name}</span>`;
              nameListElement.appendChild(li);
            });
          }
          nameCountDisplay.textContent = names.length;
        };

        return {
          updateUI: () => {
            const names = stateManager.getNames();
            _updateNameList(names);
            toggleSpinButton(stateManager.getIsSpinning());
          },
          showWinner: (winnerName) => {
            winnerDisplay.textContent = winnerName;

            // 1. Reset state for animation
            resultBox.classList.remove("active");
            resultBox.classList.add("sealed-destiny-enter");

            // 2. Activate animation and sound
            setTimeout(() => {
              resultBox.classList.add("active");
              audioController.playEvilLaugh(); // Reproducir el sonido
            }, 10);
          },
          hideResultBox: () => {
            resultBox.classList.remove("active");
            resultBox.classList.add("sealed-destiny-enter");
          },
          toggleSplatter: (visible) => {
            if (visible) {
              rouletteContainer.classList.remove("hidden-splatter");
            } else {
              rouletteContainer.classList.add("hidden-splatter");
            }
          },
          showFinishedModal: () => {
            finishedModal.classList.remove("hidden");
          },
        };
      })(StateManager, AudioController);

      /**
       * 6. APP ORCHESTRATOR (DIP: Dependency Inversion Principle & Control)
       * Inicializa la aplicaciÃ³n y orquesta la interacciÃ³n entre los diferentes mÃ³dulos.
       */
      const App = ((stateManager, uiController, wheelRenderer, config) => {
        const nameInput = document.getElementById("nameInput");
        const spinButton = document.getElementById("spinButton");
        const resetButton = document.getElementById("resetButton");
        const csvFile = document.getElementById("csvFile");

        // --- Core Logic ---
        const spinWheel = () => {
          if (
            stateManager.getIsSpinning() ||
            stateManager.getNames().length === 0
          ) {
            if (stateManager.getNames().length === 0) {
              uiController.showFinishedModal();
            }
            return;
          }

          // 1. Initial State Setup
          stateManager.setIsSpinning(true);
          uiController.updateUI();
          uiController.hideResultBox();
          uiController.toggleSplatter(true);

          const names = stateManager.getNames();
          const numNames = names.length;
          const segmentAngle = 360 / numNames;

          // 2. Select Winner and Calculate Rotation
          const winningIndex = Math.floor(Math.random() * numNames);
          const winnerName = names[winningIndex];

          const centerOfSegment =
            winningIndex * segmentAngle + segmentAngle / 2;
          // RotaciÃ³n total: 5 vueltas completas + la rotaciÃ³n necesaria para apuntar al segmento
          const totalRotation =
            360 * 5 +
            (360 - centerOfSegment) +
            Math.random() * (segmentAngle * 0.8) -
            segmentAngle * 0.4;

          // 3. Start Spin Animation
          wheelRenderer.spin(totalRotation);

          // 4. Handle Result After Animation
          setTimeout(() => {
            uiController.toggleSplatter(false);

            // Normalizar rotaciÃ³n para un stop limpio
            const normalizedRotation = totalRotation % 360;
            wheelRenderer.stopSpin(normalizedRotation);

            uiController.showWinner(winnerName);

            // Update State (Remove winner)
            stateManager.removeNameByIndex(winningIndex);

            // Update UI/Renderer
            wheelRenderer.render();
            stateManager.setIsSpinning(false);
            uiController.updateUI();

            if (stateManager.getNames().length === 0) {
              uiController.showFinishedModal();
            }
          }, config.WHEEL_DURATION);
        };

        // --- Auxiliary Handlers ---
        const addNameHandler = () => {
          const name = nameInput.value.trim();
          if (stateManager.addName(name)) {
            nameInput.value = "";
            wheelRenderer.render();
            uiController.updateUI();
          }
        };

        const resetHandler = () => {
          stateManager.resetNames();
          wheelRenderer.stopSpin(0); // Reset visual position
          uiController.hideResultBox();
          wheelRenderer.render();
          uiController.updateUI();
          csvFile.value = "";
        };

        const loadNamesFromCSV = (file) => {
          const reader = new FileReader();
          reader.onload = (e) => {
            const text = e.target.result;
            const lines = text.split("\n").filter((line) => line.trim() !== "");
            let newNames = [];
            let currentNames = stateManager.getNames();

            lines.forEach((line) => {
              const firstColumn = line.split(",")[0].trim();
              // Previene duplicados
              if (
                firstColumn &&
                !newNames.includes(firstColumn) &&
                !currentNames.includes(firstColumn)
              ) {
                newNames.push(firstColumn);
              }
            });

            if (newNames.length > 0) {
              stateManager.setNames(currentNames.concat(newNames));
              wheelRenderer.render();
              uiController.updateUI();
            } else {
              console.error(
                "ERROR: No se encontraron nombres vÃ¡lidos en la primera columna del archivo CSV o ya existen."
              );
            }
          };
          reader.onerror = () => {
            console.error("ERROR: No se pudo leer el archivo CSV.");
          };
          reader.readAsText(file);
        };

        // --- Initialization and Event Binding ---
        const init = () => {
          wheelRenderer.render();
          uiController.updateUI();

          // Event Listeners
          nameInput.addEventListener("keypress", (e) => {
            if (e.key === "Enter") {
              addNameHandler();
            }
          });
          spinButton.addEventListener("click", spinWheel);
          resetButton.addEventListener("click", resetHandler);
          csvFile.addEventListener("change", (e) => {
            const file = e.target.files[0];
            if (file) {
              loadNamesFromCSV(file);
            }
          });
        };

        return { init };
      })(StateManager, UIController, WheelRenderer, Config);

      // Iniciar la aplicaciÃ³n cuando la ventana estÃ© cargada.
      window.onload = App.init;
    </script>
  </body>
</html>
